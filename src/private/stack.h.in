// Auto-generated, don't edit.
// Copyright (c) 2017-2018 Nguyen Viet Giang. All rights reserved.
#ifndef _AVM_${STACK_TYPE_UPPER}_STACK_H_
#define _AVM_${STACK_TYPE_UPPER}_STACK_H_

#include <avm/prereq.h>
#include <avm/errno.h>
#include "${STACK_TYPE}.h"

#ifdef __cplusplus
extern "C" {
#endif

/// Dynamic sized stack.
typedef struct a${STACK_TYPE}_stack_s {
    aalloc_t *a;
    a${STACK_TYPE}_t *items;
    u32 count;
    u32 capacity;
} a${STACK_TYPE}_stack_t;

/// Reallocate stack for `capacity`, `count` maybe adjusted.
aresult_t
a${STACK_TYPE}_stack_realloc(
    a${STACK_TYPE}_stack_t *s, u32 capacity);

/// Initialize as a new stack.
AINLINE aresult_t
a${STACK_TYPE}_stack_init(
    a${STACK_TYPE}_stack_t *s, aalloc_t *a, u32 capacity)
{
    s->a = a;
    s->items = NULL;
    s->count = 0;
    s->capacity = 0;
    return a${STACK_TYPE}_stack_realloc(s, capacity);
}

/// Release all allocated memory.
AINLINE void
a${STACK_TYPE}_stack_cleanup(
    a${STACK_TYPE}_stack_t *s)
{
    AFREE(s->a, s->items);
    s->items = NULL;
    s->count = 0;
    s->capacity = 0;
}

/// Shrink the stack to reclaim memory.
AINLINE void
a${STACK_TYPE}_stack_shrink(
    a${STACK_TYPE}_stack_t *s)
{
    AVERIFY(
        ASUCCESS(a${STACK_TYPE}_stack_realloc(s, s->count)),
        "failed to reallocate to a smaller capacity?");
}

/// Ensures that there are `more` capacity.
AINLINE aresult_t
a${STACK_TYPE}_stack_reserve(
    a${STACK_TYPE}_stack_t *s, u32 more)
{
    const u32 required = s->count + more;
    return required <= s->capacity ?
        AR_SUCCESS : a${STACK_TYPE}_stack_realloc(s, required);
}

/// Push `v` to the stack.
AINLINE aresult_t
a${STACK_TYPE}_stack_push(
    a${STACK_TYPE}_stack_t *s, const a${STACK_TYPE}_t *v)
{
    const aresult_t r = a${STACK_TYPE}_stack_reserve(s, 1);
    if (AFAILED(r)) return r;
    s->items[s->count++] = *v;
    return AR_SUCCESS;
}

/// Push `v` to the stack `n` times.
AINLINE aresult_t
a${STACK_TYPE}_stack_fill(
    a${STACK_TYPE}_stack_t *s, const a${STACK_TYPE}_t *v, u32 n)
{
    u32 i;
    const aresult_t r = a${STACK_TYPE}_stack_reserve(s, n);
    if (AFAILED(r)) return r;
    else for (i = 0; i < n; ++i) s->items[s->count++] = *v;
    return AR_SUCCESS;
}

#ifdef __cplusplus
} // extern "C"
#endif

#endif // !_AVM_${STACK_TYPE_UPPER}_STACK_H_